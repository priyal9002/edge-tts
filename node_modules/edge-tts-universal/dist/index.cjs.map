{"version":3,"sources":["../src/exceptions.ts","../src/utils.ts","../src/tts_config.ts","../src/constants.ts","../src/drm.ts","../src/communicate.ts","../src/submaker.ts","../src/voices.ts","../src/simple.ts","../src/isomorphic-utils.ts","../src/isomorphic-drm.ts","../src/isomorphic-communicate.ts","../src/isomorphic-voices.ts","../src/isomorphic-simple.ts","../src/browser.ts"],"names":["uuidv4","createHash","escape","WebSocket","AxiosError","axios","connectId","unescape","dateToString","removeIncompatibleCharacters","mkssml","splitTextByByteLength","ssmlHeadersPlusData","WIN_EPOCH","S_TO_NS","_listVoices","listVoices","formatTimestamp","padNumber","createVTT","createSRT"],"mappings":"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","file":"index.cjs","sourcesContent":["/**\n * Base exception class for all Edge TTS related errors.\n */\nexport class EdgeTTSException extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"EdgeTTSException\";\n  }\n}\n\n/**\n * Exception raised when there's an error adjusting clock skew for API requests.\n * This typically occurs when the client and server clocks are significantly out of sync.\n */\nexport class SkewAdjustmentError extends EdgeTTSException {\n  constructor(message: string) {\n    super(message);\n    this.name = \"SkewAdjustmentError\";\n  }\n}\n\n/**\n * Exception raised when an unknown response is received from the TTS service.\n * This indicates an unexpected message type or format that the client cannot handle.\n */\nexport class UnknownResponse extends EdgeTTSException {\n  constructor(message: string) {\n    super(message);\n    this.name = \"UnknownResponse\";\n  }\n}\n\n/**\n * Exception raised when an unexpected response is received from the TTS service.\n * This indicates a response that doesn't match the expected protocol flow.\n */\nexport class UnexpectedResponse extends EdgeTTSException {\n  constructor(message: string) {\n    super(message);\n    this.name = \"UnexpectedResponse\";\n  }\n}\n\n/**\n * Exception raised when no audio data is received during synthesis.\n * This typically indicates a problem with the synthesis request or service.\n */\nexport class NoAudioReceived extends EdgeTTSException {\n  constructor(message: string) {\n    super(message);\n    this.name = \"NoAudioReceived\";\n  }\n}\n\n/**\n * Exception raised when there's an error with the WebSocket connection.\n * This can occur during connection establishment, data transmission, or connection closure.\n */\nexport class WebSocketError extends EdgeTTSException {\n  constructor(message: string) {\n    super(message);\n    this.name = \"WebSocketError\";\n  }\n}\n\n/**\n * Exception raised when an invalid value is provided to a function or method.\n * This is typically used for input validation errors.\n */\nexport class ValueError extends EdgeTTSException {\n  constructor(message: string) {\n    super(message);\n    this.name = \"ValueError\";\n  }\n} ","import { v4 as uuidv4 } from 'uuid';\nimport { TTSConfig } from './tts_config';\nimport { ValueError } from \"./exceptions\";\nimport escape from 'xml-escape';\n\n/**\n * Parses text-based WebSocket messages to extract headers and data.\n * @param message - Buffer containing the message to parse\n * @returns Tuple of headers object and data buffer\n */\nexport function getHeadersAndDataFromText(message: Buffer): [{ [key: string]: string }, Buffer] {\n  const headerLength = message.indexOf('\\r\\n\\r\\n');\n  const headers: { [key: string]: string } = {};\n  const headerString = message.subarray(0, headerLength).toString('utf-8');\n  if (headerString) {\n    const headerLines = headerString.split('\\r\\n');\n    for (const line of headerLines) {\n      const [key, value] = line.split(':', 2);\n      if (key && value) {\n        headers[key] = value.trim();\n      }\n    }\n  }\n\n  return [headers, message.subarray(headerLength + 2)];\n}\n\n/**\n * Parses binary WebSocket messages to extract headers and data.\n * @param message - Buffer containing the binary message to parse\n * @returns Tuple of headers object and data buffer\n */\nexport function getHeadersAndDataFromBinary(message: Buffer): [{ [key: string]: string }, Buffer] {\n  const headerLength = message.readUInt16BE(0);\n  const headers: { [key: string]: string } = {};\n  const headerString = message.subarray(2, headerLength + 2).toString('utf-8');\n  if (headerString) {\n    const headerLines = headerString.split('\\r\\n');\n    for (const line of headerLines) {\n      const [key, value] = line.split(':', 2);\n      if (key && value) {\n        headers[key] = value.trim();\n      }\n    }\n  }\n\n  return [headers, message.subarray(headerLength + 2)];\n}\n\n/**\n * Removes control characters that are incompatible with TTS processing.\n * @param text - Input text to clean\n * @returns Text with control characters replaced by spaces\n */\nexport function removeIncompatibleCharacters(text: string): string {\n  // Remove control characters (U+0000 to U+001F except \\t, \\n, \\r)\n  // eslint-disable-next-line no-control-regex\n  return text.replace(/[\\u0000-\\u0008\\u000B\\u000C\\u000E-\\u001F]/g, ' ');\n}\n\n/**\n * Generates a unique connection ID for WebSocket connections.\n * @returns UUID string with hyphens removed\n */\nexport function connectId(): string {\n  return uuidv4().replace(/-/g, '');\n}\n\nfunction _findLastNewlineOrSpaceWithinLimit(text: Buffer, limit: number): number {\n  const slice = text.subarray(0, limit);\n  let splitAt = slice.lastIndexOf('\\n');\n  if (splitAt < 0) {\n    splitAt = slice.lastIndexOf(' ');\n  }\n  return splitAt;\n}\n\nfunction _findSafeUtf8SplitPoint(textSegment: Buffer): number {\n  let splitAt = textSegment.length;\n  while (splitAt > 0) {\n    const slice = textSegment.subarray(0, splitAt);\n    // check if the slice is a valid utf8 string\n    if (slice.toString('utf-8').endsWith('')) {\n      splitAt--;\n      continue;\n    }\n    return splitAt;\n  }\n  return splitAt;\n}\n\nfunction _adjustSplitPointForXmlEntity(text: Buffer, splitAt: number): number {\n  let ampersandIndex = text.lastIndexOf('&', splitAt - 1);\n  while (ampersandIndex !== -1) {\n    const semicolonIndex = text.indexOf(';', ampersandIndex);\n    if (semicolonIndex !== -1 && semicolonIndex < splitAt) {\n      break; // Found a terminated entity\n    }\n    // Ampersand is not terminated before split_at\n    splitAt = ampersandIndex;\n    ampersandIndex = text.lastIndexOf('&', splitAt - 1);\n  }\n  return splitAt;\n}\n\n/**\n * Splits text into chunks that don't exceed the specified byte length.\n * Attempts to split at word boundaries and handles UTF-8 encoding properly.\n * @param text - Text to split (string or Buffer)\n * @param byteLength - Maximum byte length per chunk\n * @yields Buffer chunks of the split text\n * @throws {ValueError} If byteLength is too small or text has invalid structure\n */\nexport function* splitTextByByteLength(text: string | Buffer, byteLength: number): Generator<Buffer> {\n  let buffer = Buffer.isBuffer(text) ? text : Buffer.from(text, 'utf-8');\n\n  if (byteLength <= 0) {\n    throw new ValueError(\"byteLength must be greater than 0\");\n  }\n\n  while (buffer.length > byteLength) {\n    let splitAt = _findLastNewlineOrSpaceWithinLimit(buffer, byteLength);\n\n    if (splitAt < 0) {\n      splitAt = _findSafeUtf8SplitPoint(buffer.subarray(0, byteLength));\n    }\n\n    splitAt = _adjustSplitPointForXmlEntity(buffer, splitAt);\n\n    if (splitAt <= 0) {\n      throw new ValueError(\n        \"Maximum byte length is too small or \"\n        + \"invalid text structure near '&' or invalid UTF-8\"\n      );\n    }\n\n    const chunk = buffer.subarray(0, splitAt);\n    const chunkString = chunk.toString('utf-8').trim();\n    if (chunkString) {\n      yield Buffer.from(chunkString, 'utf-8');\n    }\n\n    buffer = buffer.subarray(splitAt);\n  }\n\n  const remainingChunk = buffer.toString('utf-8').trim();\n  if (remainingChunk) {\n    yield Buffer.from(remainingChunk, 'utf-8');\n  }\n}\n\n/**\n * Creates SSML (Speech Synthesis Markup Language) from text and TTS configuration.\n * @param tc - TTS configuration containing voice and prosody settings\n * @param escapedText - Text content (should be XML-escaped)\n * @returns Complete SSML document string\n */\nexport function mkssml(tc: TTSConfig, escapedText: string | Buffer): string {\n  const text = Buffer.isBuffer(escapedText) ? escapedText.toString('utf-8') : escapedText;\n  return (\n    \"<speak version='1.0' xmlns='http://www.w3.org/2001/10/synthesis' xml:lang='en-US'>\"\n    + `<voice name='${tc.voice}'>`\n    + `<prosody pitch='${tc.pitch}' rate='${tc.rate}' volume='${tc.volume}'>`\n    + `${text}`\n    + \"</prosody>\"\n    + \"</voice>\"\n    + \"</speak>\"\n  );\n}\n\n/**\n * Formats the current date as a string in the format expected by the TTS service.\n * @returns Formatted date string\n */\nexport function dateToString(): string {\n  return new Date().toUTCString().replace(\"GMT\", \"GMT+0000 (Coordinated Universal Time)\");\n}\n\n/**\n * Creates a complete WebSocket message with headers and SSML data.\n * @param requestId - Unique request identifier\n * @param timestamp - Timestamp string for the request\n * @param ssml - SSML content to include in the message\n * @returns Complete WebSocket message string with headers and data\n */\nexport function ssmlHeadersPlusData(requestId: string, timestamp: string, ssml: string): string {\n  return (\n    `X-RequestId:${requestId}\\r\\n`\n    + \"Content-Type:application/ssml+xml\\r\\n\"\n    + `X-Timestamp:${timestamp}Z\\r\\n`  // This is not a mistake, Microsoft Edge bug.\n    + \"Path:ssml\\r\\n\\r\\n\"\n    + `${ssml}`\n  );\n}\n\n/**\n * Calculates the maximum message size for text chunks based on WebSocket limits.\n * @param ttsConfig - TTS configuration to calculate overhead for\n * @returns Maximum byte size for text content in a single message\n */\nexport function calcMaxMesgSize(ttsConfig: TTSConfig): number {\n  const websocketMaxSize = 2 ** 16;\n  const overheadPerMessage = ssmlHeadersPlusData(\n    connectId(),\n    dateToString(),\n    mkssml(ttsConfig, \"\"),\n  ).length + 50; // margin of error\n  return websocketMaxSize - overheadPerMessage;\n}\n\nexport { escape };\n\n/**\n * Unescapes XML entities in text.\n * @param text - Text containing XML entities to unescape\n * @returns Text with XML entities converted back to their original characters\n */\nexport function unescape(text: string): string {\n  return text.replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>');\n} ","import { ValueError } from \"./exceptions\";\n\n/**\n * Interface defining the configuration options for TTS synthesis.\n */\nexport interface ITTSConfig {\n  /** Voice name to use for synthesis */\n  voice: string;\n  /** Speech rate adjustment (e.g., \"+20%\", \"-10%\") */\n  rate: string;\n  /** Volume level adjustment (e.g., \"+50%\", \"-25%\") */\n  volume: string;\n  /** Pitch adjustment in Hz (e.g., \"+5Hz\", \"-10Hz\") */\n  pitch: string;\n}\n\n/**\n * Configuration class for TTS synthesis parameters.\n * Handles voice name normalization and parameter validation.\n * \n * @example\n * ```typescript\n * const config = new TTSConfig({\n *   voice: 'en-US-EmmaMultilingualNeural',\n *   rate: '+20%',\n *   volume: '+10%',\n *   pitch: '+5Hz'\n * });\n * ```\n */\nexport class TTSConfig implements ITTSConfig {\n  public voice: string;\n  public rate: string;\n  public volume: string;\n  public pitch: string;\n\n  /**\n   * Creates a new TTSConfig instance with the specified parameters.\n   * \n   * @param options - Configuration options\n   * @param options.voice - Voice name (supports both short and full formats)\n   * @param options.rate - Speech rate adjustment (default: \"+0%\")\n   * @param options.volume - Volume adjustment (default: \"+0%\") \n   * @param options.pitch - Pitch adjustment (default: \"+0Hz\")\n   * @throws {ValueError} If any parameter has an invalid format\n   */\n  constructor({\n    voice,\n    rate = \"+0%\",\n    volume = \"+0%\",\n    pitch = \"+0Hz\",\n  }: {\n    voice: string,\n    rate?: string,\n    volume?: string,\n    pitch?: string,\n  }) {\n    this.voice = voice;\n    this.rate = rate;\n    this.volume = volume;\n    this.pitch = pitch;\n\n    this.validate();\n  }\n\n  private validate() {\n    // Voice validation and transformation\n    const match = /^([a-z]{2,})-([A-Z]{2,})-(.+Neural)$/.exec(this.voice);\n    if (match) {\n      const [, lang] = match;\n      let [, , region, name] = match;\n      if (name.includes('-')) {\n        const parts = name.split('-');\n        region += `-${parts[0]}`;\n        name = parts[1];\n      }\n      this.voice = `Microsoft Server Speech Text to Speech Voice (${lang}-${region}, ${name})`;\n    }\n\n    TTSConfig.validateStringParam(\n      \"voice\",\n      this.voice,\n      /^Microsoft Server Speech Text to Speech Voice \\(.+,.+\\)$/\n    );\n    TTSConfig.validateStringParam(\"rate\", this.rate, /^[+-]\\d+%$/);\n    TTSConfig.validateStringParam(\"volume\", this.volume, /^[+-]\\d+%$/);\n    TTSConfig.validateStringParam(\"pitch\", this.pitch, /^[+-]\\d+Hz$/);\n  }\n\n  private static validateStringParam(paramName: string, paramValue: string, pattern: RegExp) {\n    if (typeof paramValue !== 'string') {\n      throw new TypeError(`${paramName} must be a string`);\n    }\n    if (!pattern.test(paramValue)) {\n      throw new ValueError(`Invalid ${paramName} '${paramValue}'.`);\n    }\n  }\n} ","/** Base URL for Microsoft Edge TTS service endpoints */\nexport const BASE_URL = \"speech.platform.bing.com/consumer/speech/synthesize/readaloud\";\n\n/** Trusted client token used for authentication with the TTS service */\nexport const TRUSTED_CLIENT_TOKEN = \"6A5AA1D4EAFF4E9FB37E23D68491D6F4\";\n\n/** WebSocket URL for TTS streaming synthesis */\nexport const WSS_URL = `wss://${BASE_URL}/edge/v1?TrustedClientToken=${TRUSTED_CLIENT_TOKEN}`;\n\n/** HTTP URL for fetching available voices list */\nexport const VOICE_LIST_URL = `https://${BASE_URL}/voices/list?trustedclienttoken=${TRUSTED_CLIENT_TOKEN}`;\n\n/** Default voice to use when none is specified */\nexport const DEFAULT_VOICE = \"en-US-EmmaMultilingualNeural\";\n\n/** Version string for Chromium browser emulation */\nexport const CHROMIUM_FULL_VERSION = \"130.0.2849.68\";\n\n/** Major version number extracted from the full Chromium version */\nexport const CHROMIUM_MAJOR_VERSION = CHROMIUM_FULL_VERSION.split(\".\")[0];\n\n/** Security token version for API authentication */\nexport const SEC_MS_GEC_VERSION = `1-${CHROMIUM_FULL_VERSION}`;\n\n/** Base HTTP headers for API requests, mimicking a real browser */\nexport const BASE_HEADERS = {\n  \"User-Agent\": `Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/${CHROMIUM_MAJOR_VERSION}.0.0.0 Safari/537.36 Edg/${CHROMIUM_MAJOR_VERSION}.0.0.0`,\n  \"Accept-Encoding\": \"gzip, deflate, br\",\n  \"Accept-Language\": \"en-US,en;q=0.9\",\n};\n\n/** HTTP headers specific to WebSocket connection requests */\nexport const WSS_HEADERS = {\n  ...BASE_HEADERS,\n  \"Pragma\": \"no-cache\",\n  \"Cache-Control\": \"no-cache\",\n  \"Origin\": \"chrome-extension://jdiccldimpdaibmpdkjnbmckianbfold\",\n};\n\n/** HTTP headers specific to voice list API requests */\nexport const VOICE_HEADERS = {\n  ...BASE_HEADERS,\n  \"Authority\": \"speech.platform.bing.com\",\n  \"Sec-CH-UA\": `\" Not;A Brand\";v=\"99\", \"Microsoft Edge\";v=\"${CHROMIUM_MAJOR_VERSION}\", \"Chromium\";v=\"${CHROMIUM_MAJOR_VERSION}\"`,\n  \"Sec-CH-UA-Mobile\": \"?0\",\n  \"Accept\": \"*/*\",\n  \"Sec-Fetch-Site\": \"none\",\n  \"Sec-Fetch-Mode\": \"cors\",\n  \"Sec-Fetch-Dest\": \"empty\",\n}; ","import { createHash } from 'crypto';\nimport { TRUSTED_CLIENT_TOKEN } from './constants';\nimport { SkewAdjustmentError } from \"./exceptions\";\nimport { AxiosError } from \"axios\";\n\nconst WIN_EPOCH = 11644473600;\nconst S_TO_NS = 1e9;\n\n/**\n * Digital Rights Management (DRM) class for handling authentication with Microsoft Edge TTS service.\n * Manages clock synchronization and security token generation for Node.js environments.\n */\nexport class DRM {\n  private static clockSkewSeconds = 0.0;\n\n  /**\n   * Adjusts the clock skew to synchronize with server time.\n   * @param skewSeconds - Number of seconds to adjust the clock by\n   */\n  static adjClockSkewSeconds(skewSeconds: number) {\n    DRM.clockSkewSeconds += skewSeconds;\n  }\n\n  /**\n   * Gets the current Unix timestamp adjusted for clock skew.\n   * @returns Unix timestamp in seconds\n   */\n  static getUnixTimestamp(): number {\n    return Date.now() / 1000 + DRM.clockSkewSeconds;\n  }\n\n  /**\n   * Parses an RFC 2616 date string into a Unix timestamp.\n   * @param date - RFC 2616 formatted date string\n   * @returns Unix timestamp in seconds, or null if parsing fails\n   */\n  static parseRfc2616Date(date: string): number | null {\n    try {\n      // The python version uses strptime with %Z, but it mentions it's not quite right.\n      // JS's Date parsing is generally good with RFC 2616 dates.\n      // And since it's UTC, it should be fine.\n      return new Date(date).getTime() / 1000;\n    } catch (e) {\n      return null;\n    }\n  }\n\n  /**\n   * Handles client response errors by adjusting clock skew based on server date.\n   * @param e - Axios error containing server response headers\n   * @throws {SkewAdjustmentError} If server date is missing or invalid\n   */\n  static handleClientResponseError(e: AxiosError) {\n    if (!e.response || !e.response.headers) {\n      throw new SkewAdjustmentError(\"No server date in headers.\");\n    }\n    const serverDate = e.response.headers[\"date\"];\n    if (!serverDate || typeof serverDate !== 'string') {\n      throw new SkewAdjustmentError(\"No server date in headers.\");\n    }\n    const serverDateParsed = DRM.parseRfc2616Date(serverDate);\n    if (serverDateParsed === null) {\n      throw new SkewAdjustmentError(`Failed to parse server date: ${serverDate}`);\n    }\n    const clientDate = DRM.getUnixTimestamp();\n    DRM.adjClockSkewSeconds(serverDateParsed - clientDate);\n  }\n\n  /**\n   * Generates the Sec-MS-GEC security token required for API authentication.\n   * @returns Uppercase hexadecimal SHA-256 hash string\n   */\n  static generateSecMsGec(): string {\n    let ticks = DRM.getUnixTimestamp();\n    ticks += WIN_EPOCH;\n    ticks -= ticks % 300;\n    ticks *= S_TO_NS / 100;\n\n    const strToHash = `${ticks.toFixed(0)}${TRUSTED_CLIENT_TOKEN}`;\n    return createHash('sha256').update(strToHash, 'ascii').digest('hex').toUpperCase();\n  }\n} ","import {\n  connectId,\n  dateToString,\n  escape,\n  getHeadersAndDataFromBinary,\n  getHeadersAndDataFromText,\n  mkssml,\n  removeIncompatibleCharacters,\n  splitTextByByteLength,\n  ssmlHeadersPlusData,\n  unescape\n} from './utils';\nimport {\n  NoAudioReceived,\n  UnexpectedResponse,\n  UnknownResponse,\n  WebSocketError\n} from \"./exceptions\";\nimport { TTSConfig } from './tts_config';\nimport { CommunicateState, TTSChunk } from './types';\n// Use isomorphic WebSocket that works in both Node.js and browsers\nimport WebSocket from 'isomorphic-ws';\nimport { DEFAULT_VOICE, WSS_URL, WSS_HEADERS, SEC_MS_GEC_VERSION } from './constants';\nimport { DRM } from './drm';\nimport { AxiosError } from 'axios';\n\n// HttpsProxyAgent will be imported dynamically when needed\nlet HttpsProxyAgent: any;\n\n/**\n * Configuration options for the Communicate class.\n */\nexport interface CommunicateOptions {\n  /** Voice to use for synthesis (e.g., \"en-US-EmmaMultilingualNeural\") */\n  voice?: string;\n  /** Speech rate adjustment (e.g., \"+20%\", \"-10%\") */\n  rate?: string;\n  /** Volume level adjustment (e.g., \"+50%\", \"-25%\") */\n  volume?: string;\n  /** Pitch adjustment in Hz (e.g., \"+5Hz\", \"-10Hz\") */\n  pitch?: string;\n  /** Proxy URL for requests */\n  proxy?: string;\n  /** WebSocket connection timeout in milliseconds */\n  connectionTimeout?: number;\n}\n\n/**\n * Main class for text-to-speech synthesis using Microsoft Edge's online TTS service.\n * \n * @example\n * ```typescript\n * const communicate = new Communicate('Hello, world!', {\n *   voice: 'en-US-EmmaMultilingualNeural',\n * });\n * \n * for await (const chunk of communicate.stream()) {\n *   if (chunk.type === 'audio' && chunk.data) {\n *     // Handle audio data\n *   }\n * }\n * ```\n */\nexport class Communicate {\n  private readonly ttsConfig: TTSConfig;\n  private readonly texts: Generator<Buffer>;\n  private readonly proxy?: string;\n  private readonly connectionTimeout?: number;\n\n  private state: CommunicateState = {\n    partialText: Buffer.from(''),\n    offsetCompensation: 0,\n    lastDurationOffset: 0,\n    streamWasCalled: false,\n  };\n\n  /**\n   * Creates a new Communicate instance for text-to-speech synthesis.\n   * \n   * @param text - The text to synthesize\n   * @param options - Configuration options for synthesis\n   */\n  constructor(text: string, options: CommunicateOptions = {}) {\n    this.ttsConfig = new TTSConfig({\n      voice: options.voice || DEFAULT_VOICE,\n      rate: options.rate,\n      volume: options.volume,\n      pitch: options.pitch,\n    });\n\n    if (typeof text !== 'string') {\n      throw new TypeError('text must be a string');\n    }\n\n    this.texts = splitTextByByteLength(\n      escape(removeIncompatibleCharacters(text)),\n      // calcMaxMesgSize(this.ttsConfig),\n      4096,\n    );\n\n    this.proxy = options.proxy;\n    this.connectionTimeout = options.connectionTimeout;\n  }\n\n  private parseMetadata(data: Buffer): TTSChunk {\n    const metadata = JSON.parse(data.toString('utf-8'));\n    for (const metaObj of metadata['Metadata']) {\n      const metaType = metaObj['Type'];\n      if (metaType === 'WordBoundary') {\n        const currentOffset = metaObj['Data']['Offset'] + this.state.offsetCompensation;\n        const currentDuration = metaObj['Data']['Duration'];\n        return {\n          type: metaType,\n          offset: currentOffset,\n          duration: currentDuration,\n          text: unescape(metaObj['Data']['text']['Text']),\n        };\n      }\n      if (metaType === 'SessionEnd') {\n        continue;\n      }\n      throw new UnknownResponse(`Unknown metadata type: ${metaType}`);\n    }\n    throw new UnexpectedResponse('No WordBoundary metadata found');\n  }\n\n  private async * _stream(): AsyncGenerator<TTSChunk, void, unknown> {\n    const url = `${WSS_URL}&Sec-MS-GEC=${DRM.generateSecMsGec()}&Sec-MS-GEC-Version=${SEC_MS_GEC_VERSION}&ConnectionId=${connectId()}`;\n\n    let agent: any;\n    if (this.proxy) {\n      // Import HttpsProxyAgent dynamically only when needed\n      if (!HttpsProxyAgent) {\n        try {\n          const proxyModule = await import('https-proxy-agent');\n          HttpsProxyAgent = proxyModule.HttpsProxyAgent;\n        } catch (e) {\n          console.warn('https-proxy-agent not available:', e);\n        }\n      }\n      if (HttpsProxyAgent) {\n        agent = new HttpsProxyAgent(this.proxy);\n      }\n    }\n\n    const websocket = new WebSocket(url, {\n      headers: WSS_HEADERS,\n      timeout: this.connectionTimeout,\n      agent: agent,\n    });\n\n    const messageQueue: (TTSChunk | Error | 'close')[] = [];\n    let resolveMessage: (() => void) | null = null;\n\n    websocket.on('message', (message: Buffer, isBinary: boolean) => {\n      if (!isBinary) {\n        // text message\n        const [headers, data] = getHeadersAndDataFromText(message);\n\n        const path = headers['Path'];\n        if (path === 'audio.metadata') {\n          try {\n            const parsedMetadata = this.parseMetadata(data);\n            this.state.lastDurationOffset = parsedMetadata.offset! + parsedMetadata.duration!;\n            messageQueue.push(parsedMetadata);\n          } catch (e) {\n            messageQueue.push(e as Error);\n          }\n        } else if (path === 'turn.end') {\n          this.state.offsetCompensation = this.state.lastDurationOffset;\n          websocket.close();\n        } else if (path !== 'response' && path !== 'turn.start') {\n          messageQueue.push(new UnknownResponse(`Unknown path received: ${path}`));\n        }\n      } else {\n        // binary message\n        if (message.length < 2) {\n          messageQueue.push(new UnexpectedResponse('We received a binary message, but it is missing the header length.'));\n        } else {\n          const headerLength = message.readUInt16BE(0);\n          if (headerLength > message.length) {\n            messageQueue.push(new UnexpectedResponse('The header length is greater than the length of the data.'));\n          } else {\n            const [headers, data] = getHeadersAndDataFromBinary(message);\n\n            if (headers['Path'] !== 'audio') {\n              messageQueue.push(new UnexpectedResponse('Received binary message, but the path is not audio.'));\n            } else {\n              const contentType = headers['Content-Type'];\n              if (contentType !== 'audio/mpeg') {\n                if (data.length > 0) {\n                  messageQueue.push(new UnexpectedResponse('Received binary message, but with an unexpected Content-Type.'));\n                }\n              } else if (data.length === 0) {\n                messageQueue.push(new UnexpectedResponse('Received binary message, but it is missing the audio data.'));\n              } else {\n                messageQueue.push({ type: 'audio', data: data });\n              }\n            }\n          }\n        }\n      }\n      if (resolveMessage) resolveMessage();\n    });\n\n    websocket.on('error', (error) => {\n      messageQueue.push(new WebSocketError(error.message));\n      if (resolveMessage) resolveMessage();\n    });\n\n    websocket.on('close', () => {\n      messageQueue.push('close');\n      if (resolveMessage) resolveMessage();\n    });\n\n    await new Promise<void>(resolve => websocket.on('open', resolve));\n\n    websocket.send(\n      `X-Timestamp:${dateToString()}\\r\\n`\n      + 'Content-Type:application/json; charset=utf-8\\r\\n'\n      + 'Path:speech.config\\r\\n\\r\\n'\n      + '{\"context\":{\"synthesis\":{\"audio\":{\"metadataoptions\":{'\n      + '\"sentenceBoundaryEnabled\":\"false\",\"wordBoundaryEnabled\":\"true\"},'\n      + '\"outputFormat\":\"audio-24khz-48kbitrate-mono-mp3\"'\n      + '}}}}\\r\\n'\n    );\n\n    websocket.send(\n      ssmlHeadersPlusData(\n        connectId(),\n        dateToString(),\n        mkssml(this.ttsConfig, this.state.partialText),\n      )\n    );\n\n    let audioWasReceived = false;\n    while (true) {\n      if (messageQueue.length > 0) {\n        const message = messageQueue.shift()!;\n        if (message === 'close') {\n          if (!audioWasReceived) {\n            throw new NoAudioReceived('No audio was received.');\n          }\n          break;\n        } else if (message instanceof Error) {\n          throw message;\n        } else {\n          if (message.type === 'audio') audioWasReceived = true;\n          yield message;\n        }\n      } else {\n        // Use a more responsive wait mechanism\n        await new Promise<void>(resolve => {\n          resolveMessage = resolve;\n          // Add a small timeout to prevent indefinite waiting\n          setTimeout(resolve, 50);\n        });\n      }\n    }\n  }\n\n  /**\n   * Streams text-to-speech synthesis results.\n   * \n   * Returns an async generator that yields audio chunks and word boundary events.\n   * Can only be called once per Communicate instance.\n   * \n   * @yields TTSChunk - Audio data or word boundary information\n   * @throws {Error} If called more than once\n   * @throws {NoAudioReceived} If no audio data is received\n   * @throws {WebSocketError} If WebSocket connection fails\n   * \n   * @example\n   * ```typescript\n   * for await (const chunk of communicate.stream()) {\n   *   if (chunk.type === 'audio') {\n   *     // Process audio data\n   *   } else if (chunk.type === 'WordBoundary') {\n   *     // Process subtitle timing\n   *   }\n   * }\n   * ```\n   */\n  async * stream(): AsyncGenerator<TTSChunk, void, unknown> {\n    if (this.state.streamWasCalled) {\n      throw new Error('stream can only be called once.');\n    }\n    this.state.streamWasCalled = true;\n\n    for (const partialText of this.texts) {\n      this.state.partialText = partialText;\n      try {\n        for await (const message of this._stream()) {\n          yield message;\n        }\n      } catch (e) {\n        if (e instanceof AxiosError && e.response?.status === 403) {\n          DRM.handleClientResponseError(e);\n          for await (const message of this._stream()) {\n            yield message;\n          }\n        } else {\n          throw e;\n        }\n      }\n    }\n  }\n} ","import { TTSChunk } from \"./types\";\nimport { ValueError } from \"./exceptions\";\n\ninterface Cue {\n  index: number;\n  start: number; // in seconds\n  end: number; // in seconds\n  content: string;\n}\n\nfunction formatTime(seconds: number): string {\n  const h = Math.floor(seconds / 3600);\n  const m = Math.floor((seconds % 3600) / 60);\n  const s = Math.floor(seconds % 60);\n  const ms = Math.round((seconds - Math.floor(seconds)) * 1000);\n\n  const pad = (num: number, size = 2) => num.toString().padStart(size, '0');\n\n  return `${pad(h)}:${pad(m)}:${pad(s)},${pad(ms, 3)}`;\n}\n\n/**\n * Utility class for generating SRT subtitles from WordBoundary events.\n * \n * @example\n * ```typescript\n * const subMaker = new SubMaker();\n * \n * for await (const chunk of communicate.stream()) {\n *   if (chunk.type === 'WordBoundary') {\n *     subMaker.feed(chunk);\n *   }\n * }\n * \n * const srt = subMaker.getSrt();\n * ```\n */\nexport class SubMaker {\n  private cues: Cue[] = [];\n\n  /**\n   * Adds a WordBoundary chunk to the subtitle maker.\n   * \n   * @param msg - Must be a WordBoundary type chunk with offset, duration, and text\n   * @throws {ValueError} If chunk is not a WordBoundary with required fields\n   */\n  feed(msg: TTSChunk): void {\n    if (msg.type !== 'WordBoundary' || msg.offset === undefined || msg.duration === undefined || msg.text === undefined) {\n      throw new ValueError(\"Invalid message type, expected 'WordBoundary' with offset, duration and text\");\n    }\n\n    // offset and duration are in 100-nanosecond intervals.\n    // srt timestamps are in seconds. 1s = 10^7 * 100ns\n    const start = msg.offset / 1e7;\n    const end = (msg.offset + msg.duration) / 1e7;\n\n    this.cues.push({\n      index: this.cues.length + 1,\n      start: start,\n      end: end,\n      content: msg.text,\n    });\n  }\n\n  /**\n   * Merges consecutive cues to create subtitle entries with multiple words.\n   * This is useful for creating more readable subtitles instead of word-by-word display.\n   * \n   * @param words - Maximum number of words per merged cue\n   * @throws {ValueError} If words parameter is invalid\n   */\n  mergeCues(words: number): void {\n    if (words <= 0) {\n      throw new ValueError(\"Invalid number of words to merge, expected > 0\");\n    }\n    if (this.cues.length === 0) {\n      return;\n    }\n\n    const newCues: Cue[] = [];\n    let currentCue: Cue = this.cues[0];\n\n    for (const cue of this.cues.slice(1)) {\n      if (currentCue.content.split(' ').length < words) {\n        currentCue = {\n          ...currentCue,\n          end: cue.end,\n          content: `${currentCue.content} ${cue.content}`,\n        };\n      } else {\n        newCues.push(currentCue);\n        currentCue = cue;\n      }\n    }\n    newCues.push(currentCue);\n\n    // re-index\n    this.cues = newCues.map((cue, i) => ({ ...cue, index: i + 1 }));\n  }\n\n  /**\n   * Returns the subtitles in SRT format.\n   * \n   * @returns SRT formatted subtitles\n   */\n  getSrt(): string {\n    return this.cues.map(cue => {\n      return `${cue.index}\\r\\n${formatTime(cue.start)} --> ${formatTime(cue.end)}\\r\\n${cue.content}\\r\\n`;\n    }).join('\\r\\n');\n  }\n\n  toString(): string {\n    return this.getSrt();\n  }\n} ","import axios, { AxiosError, AxiosProxyConfig } from 'axios';\nimport { SEC_MS_GEC_VERSION, VOICE_HEADERS, VOICE_LIST_URL } from './constants';\nimport { DRM } from './drm';\nimport { Voice, VoicesManagerFind, VoicesManagerVoice } from './types';\n\nfunction buildProxyConfig(proxy: string): AxiosProxyConfig | false {\n  try {\n    const proxyUrl = new URL(proxy);\n    return {\n      host: proxyUrl.hostname,\n      port: parseInt(proxyUrl.port),\n      protocol: proxyUrl.protocol,\n    };\n  } catch (e) {\n    // if proxy is not a valid URL, just ignore it.\n    return false;\n  }\n}\n\nasync function _listVoices(proxy?: string): Promise<Voice[]> {\n  const url = `${VOICE_LIST_URL}&Sec-MS-GEC=${DRM.generateSecMsGec()}&Sec-MS-GEC-Version=${SEC_MS_GEC_VERSION}`;\n  const response = await axios.get<Voice[]>(url, {\n    headers: VOICE_HEADERS,\n    proxy: proxy ? buildProxyConfig(proxy) : false,\n  });\n\n  const data = response.data;\n\n  for (const voice of data) {\n    voice.VoiceTag.ContentCategories = voice.VoiceTag.ContentCategories.map(c => c.trim() as any);\n    voice.VoiceTag.VoicePersonalities = voice.VoiceTag.VoicePersonalities.map(p => p.trim() as any);\n  }\n\n  return data;\n}\n\n/**\n * Fetches all available voices from the Microsoft Edge TTS service.\n * \n * @param proxy - Optional proxy URL for the request\n * @returns Promise resolving to array of available voices\n */\nexport async function listVoices(proxy?: string): Promise<Voice[]> {\n  try {\n    return await _listVoices(proxy);\n  } catch (e) {\n    if (e instanceof AxiosError && e.response?.status === 403) {\n      DRM.handleClientResponseError(e);\n      return await _listVoices(proxy);\n    }\n    throw e;\n  }\n}\n\n/**\n * Utility class for finding and filtering available voices.\n * \n * @example\n * ```typescript\n * const voicesManager = await VoicesManager.create();\n * const englishVoices = voicesManager.find({ Language: 'en' });\n * ```\n */\nexport class VoicesManager {\n  private voices: VoicesManagerVoice[] = [];\n  private calledCreate = false;\n\n  /**\n   * Creates a new VoicesManager instance.\n   * \n   * @param customVoices - Optional custom voice list instead of fetching from API\n   * @param proxy - Optional proxy URL for API requests\n   * @returns Promise resolving to VoicesManager instance\n   */\n  public static async create(customVoices?: Voice[], proxy?: string): Promise<VoicesManager> {\n    const manager = new VoicesManager();\n    const voices = customVoices ?? await listVoices(proxy);\n    manager.voices = voices.map(voice => ({\n      ...voice,\n      Language: voice.Locale.split('-')[0],\n    }));\n    manager.calledCreate = true;\n    return manager;\n  }\n\n  /**\n   * Finds voices matching the specified criteria.\n   * \n   * @param filter - Filter criteria for voice selection\n   * @returns Array of voices matching the filter\n   * @throws {Error} If called before create()\n   */\n  public find(filter: VoicesManagerFind): VoicesManagerVoice[] {\n    if (!this.calledCreate) {\n      throw new Error('VoicesManager.find() called before VoicesManager.create()');\n    }\n\n    return this.voices.filter(voice => {\n      return Object.entries(filter).every(([key, value]) => {\n        return voice[key as keyof VoicesManagerFind] === value;\n      });\n    });\n  }\n} ","import { Communicate } from './communicate';\n\n/**\n * Options for controlling the voice prosody (rate, pitch, volume).\n */\nexport interface ProsodyOptions {\n  /**\n   * The speaking rate of the voice.\n   * Examples: \"+10.00%\", \"-20.00%\"\n   */\n  rate?: string;\n  /**\n   * The speaking volume of the voice.\n   * Examples: \"+15.00%\", \"-10.00%\"\n   */\n  volume?: string;\n  /**\n   * The speaking pitch of the voice.\n   * Examples: \"+20Hz\", \"-10Hz\"\n   */\n  pitch?: string;\n}\n\n/**\n * Represents a single word boundary with its timing and text.\n * The API provides timing in 100-nanosecond units.\n */\nexport interface WordBoundary {\n  /**\n   * The offset from the beginning of the audio stream in 100-nanosecond units.\n   */\n  offset: number;\n  /**\n   * The duration of the word in 100-nanosecond units.\n   */\n  duration: number;\n  /**\n   * The text of the spoken word.\n   */\n  text: string;\n}\n\n/**\n * The final result of the synthesis process.\n */\nexport interface SynthesisResult {\n  /**\n   * The generated audio as a Blob, which can be used in an <audio> element.\n   */\n  audio: Blob;\n  /**\n   * An array of word boundaries containing timing and text for creating subtitles.\n   */\n  subtitle: WordBoundary[];\n}\n\n/**\n * Simple Edge TTS class that provides the same API as the standalone implementation\n * but uses the robust infrastructure of the modular project.\n */\nexport class EdgeTTS {\n  public text: string;\n  public voice: string;\n  public rate: string;\n  public volume: string;\n  public pitch: string;\n\n  /**\n   * @param text The text to be synthesized.\n   * @param voice The voice to use for synthesis.\n   * @param options Prosody options (rate, volume, pitch).\n   */\n  constructor(\n    text: string,\n    voice = \"Microsoft Server Speech Text to Speech Voice (zh-CN, XiaoxiaoNeural)\",\n    options: ProsodyOptions = {}\n  ) {\n    this.text = text;\n    this.voice = voice;\n    this.rate = options.rate || \"+0%\";\n    this.volume = options.volume || \"+0%\";\n    this.pitch = options.pitch || \"+0Hz\";\n  }\n\n  /**\n   * Initiates the synthesis process.\n   * @returns A promise that resolves with the synthesized audio and subtitle data.\n   */\n  public async synthesize(): Promise<SynthesisResult> {\n    const communicate = new Communicate(this.text, {\n      voice: this.voice,\n      rate: this.rate,\n      volume: this.volume,\n      pitch: this.pitch,\n    });\n\n    const audioChunks: Buffer[] = [];\n    const wordBoundaries: WordBoundary[] = [];\n\n    for await (const chunk of communicate.stream()) {\n      if (chunk.type === 'audio' && chunk.data) {\n        audioChunks.push(chunk.data);\n      } else if (chunk.type === 'WordBoundary' && chunk.offset !== undefined && chunk.duration !== undefined && chunk.text !== undefined) {\n        wordBoundaries.push({\n          offset: chunk.offset,\n          duration: chunk.duration,\n          text: chunk.text,\n        });\n      }\n    }\n\n    // Convert Buffer array to Blob\n    const audioBuffer = Buffer.concat(audioChunks);\n    const audioBlob = new Blob([audioBuffer], { type: \"audio/mpeg\" });\n\n    return {\n      audio: audioBlob,\n      subtitle: wordBoundaries,\n    };\n  }\n}\n\n// ==================================================================================\n// Subtitle Generation Utilities (from code (54).ts)\n// ==================================================================================\n\n/**\n * Formats a time value from 100-nanosecond units into a VTT or SRT timestamp string.\n * @param timeIn100ns The time value in 100-nanosecond units.\n * @param format The subtitle format, which determines the decimal separator.\n * @returns A formatted timestamp string (e.g., \"00:01:23.456\").\n */\nfunction formatTimestamp(timeIn100ns: number, format: 'vtt' | 'srt'): string {\n  const totalSeconds = Math.floor(timeIn100ns / 10000000);\n  const hours = Math.floor(totalSeconds / 3600);\n  const minutes = Math.floor((totalSeconds % 3600) / 60);\n  const seconds = totalSeconds % 60;\n  const milliseconds = Math.floor((timeIn100ns % 10000000) / 10000);\n  const separator = format === 'vtt' ? '.' : ',';\n  return `${padNumber(hours)}:${padNumber(minutes)}:${padNumber(seconds)}${separator}${padNumber(milliseconds, 3)}`;\n}\n\n/**\n * Pads a number with leading zeros to a specified length.\n * @param num The number to pad.\n * @param length The desired length of the string.\n * @returns The padded number as a string.\n */\nfunction padNumber(num: number, length = 2): string {\n  return num.toString().padStart(length, '0');\n}\n\n/**\n * Creates a subtitle file content in VTT (WebVTT) format.\n * @param wordBoundaries The array of word boundary data.\n * @returns A string containing the VTT formatted subtitles.\n */\nexport function createVTT(wordBoundaries: WordBoundary[]): string {\n  let vttContent = \"WEBVTT\\n\\n\";\n  wordBoundaries.forEach((word, index) => {\n    const startTime = formatTimestamp(word.offset, 'vtt');\n    const endTime = formatTimestamp(word.offset + word.duration, 'vtt');\n    vttContent += `${index + 1}\\n`;\n    vttContent += `${startTime} --> ${endTime}\\n`;\n    vttContent += `${word.text}\\n\\n`;\n  });\n  return vttContent;\n}\n\n/**\n * Creates a subtitle file content in SRT (SubRip) format.\n * @param wordBoundaries The array of word boundary data.\n * @returns A string containing the SRT formatted subtitles.\n */\nexport function createSRT(wordBoundaries: WordBoundary[]): string {\n  let srtContent = \"\";\n  wordBoundaries.forEach((word, index) => {\n    const startTime = formatTimestamp(word.offset, 'srt');\n    const endTime = formatTimestamp(word.offset + word.duration, 'srt');\n    srtContent += `${index + 1}\\n`;\n    srtContent += `${startTime} --> ${endTime}\\n`;\n    srtContent += `${word.text}\\n\\n`;\n  });\n  return srtContent;\n}\n\n// Universal alias for EdgeTTS (preferred naming)\nexport { EdgeTTS as UniversalEdgeTTS }; ","/**\n * Isomorphic utilities that work in both Node.js and browsers using only Web APIs.\n * This module provides browser-compatible implementations without Node.js dependencies.\n */\n\nimport { TTSConfig } from './tts_config';\nimport { ValueError } from \"./exceptions\";\n\n/**\n * Generates a UUID v4 string without hyphens using Web Crypto API.\n * Works in both Node.js (with globalThis.crypto) and browsers.\n */\nexport function connectId(): string {\n  // Use Web Crypto API available in both Node.js 16+ and all modern browsers\n  const array = new Uint8Array(16);\n  globalThis.crypto.getRandomValues(array);\n\n  // Set version (4) and variant bits according to RFC 4122\n  array[6] = (array[6] & 0x0f) | 0x40;\n  array[8] = (array[8] & 0x3f) | 0x80;\n\n  // Convert to hex string and format as UUID, then remove hyphens\n  const hex = Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');\n  const uuid = `${hex.slice(0, 8)}-${hex.slice(8, 12)}-${hex.slice(12, 16)}-${hex.slice(16, 20)}-${hex.slice(20, 32)}`;\n\n  return uuid.replace(/-/g, '');\n}\n\n/**\n * Web-native XML escaping function.\n */\nexport function escape(text: string): string {\n  return text\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&apos;');\n}\n\n/**\n * Unescapes XML entities in text.\n */\nexport function unescape(text: string): string {\n  return text\n    .replace(/&quot;/g, '\"')\n    .replace(/&apos;/g, \"'\")\n    .replace(/&lt;/g, '<')\n    .replace(/&gt;/g, '>')\n    .replace(/&amp;/g, '&');\n}\n\n/**\n * Parses text-based WebSocket messages to extract headers and data.\n * Uses Uint8Array for universal compatibility.\n */\nexport function getHeadersAndDataFromText(message: Uint8Array): [{ [key: string]: string }, Uint8Array] {\n  const messageString = new TextDecoder().decode(message);\n  const headerEndIndex = messageString.indexOf('\\r\\n\\r\\n');\n\n  const headers: { [key: string]: string } = {};\n  if (headerEndIndex !== -1) {\n    const headerString = messageString.substring(0, headerEndIndex);\n    const headerLines = headerString.split('\\r\\n');\n    for (const line of headerLines) {\n      const [key, value] = line.split(':', 2);\n      if (key && value) {\n        headers[key] = value.trim();\n      }\n    }\n  }\n\n  const headerByteLength = new TextEncoder().encode(messageString.substring(0, headerEndIndex + 4)).length;\n  return [headers, message.slice(headerByteLength)];\n}\n\n/**\n * Parses binary WebSocket messages to extract headers and data.\n * Uses Uint8Array for universal compatibility.\n */\nexport function getHeadersAndDataFromBinary(message: Uint8Array): [{ [key: string]: string }, Uint8Array] {\n  if (message.length < 2) {\n    throw new Error('Message too short to contain header length');\n  }\n\n  const headerLength = (message[0] << 8) | message[1]; // Read big-endian uint16\n  const headers: { [key: string]: string } = {};\n\n  if (headerLength > 0 && headerLength + 2 <= message.length) {\n    const headerBytes = message.slice(2, headerLength + 2);\n    const headerString = new TextDecoder().decode(headerBytes);\n    const headerLines = headerString.split('\\r\\n');\n    for (const line of headerLines) {\n      const [key, value] = line.split(':', 2);\n      if (key && value) {\n        headers[key] = value.trim();\n      }\n    }\n  }\n\n  return [headers, message.slice(headerLength + 2)];\n}\n\n/**\n * Converts a date to the expected string format for WebSocket messages.\n */\nexport function dateToString(date?: Date): string {\n  if (!date) {\n    date = new Date();\n  }\n  return date.toISOString().replace(/[-:.]/g, '').slice(0, -1);\n}\n\n/**\n * Removes characters that are incompatible with SSML.\n * Preserves essential punctuation (.?;:!,) for natural speech pauses.\n * XML special characters (&<>\"') are handled by the escape() function.\n */\nexport function removeIncompatibleCharacters(str: string): string {\n  // Keep essential punctuation for natural speech: .?;:!,\n  // Remove characters that could break SSML structure or cause parsing issues\n  const chars_to_remove = \"*/()[]{}$%^@#+=|\\\\~`><\\\"&\";\n  let clean_str = str;\n  for (const char of chars_to_remove) {\n    clean_str = clean_str.replace(new RegExp('\\\\' + char, 'g'), '');\n  }\n  return clean_str;\n}\n\n/**\n * Creates SSML from TTS configuration and text.\n * Compatible with original mkssml function signature.\n */\nexport function mkssml(tc: TTSConfig, escapedText: string | Uint8Array): string {\n  const text = escapedText instanceof Uint8Array ? new TextDecoder().decode(escapedText) : escapedText;\n  return (\n    \"<speak version='1.0' xmlns='http://www.w3.org/2001/10/synthesis' xml:lang='en-US'>\"\n    + `<voice name='${tc.voice}'>`\n    + `<prosody pitch='${tc.pitch}' rate='${tc.rate}' volume='${tc.volume}'>`\n    + `${text}`\n    + \"</prosody>\"\n    + \"</voice>\"\n    + \"</speak>\"\n  );\n}\n\n/**\n * Splits text by byte length while respecting word boundaries.\n */\nexport function splitTextByByteLength(text: string, byteLength: number): string[] {\n  const encoder = new TextEncoder();\n  const words = text.split(/(\\s+)/); // Split by whitespace but keep delimiters\n  const chunks: string[] = [];\n  let currentChunk = \"\";\n\n  for (const word of words) {\n    const potentialChunk = currentChunk + word;\n    if (encoder.encode(potentialChunk).length <= byteLength) {\n      currentChunk = potentialChunk;\n    } else {\n      if (currentChunk) {\n        chunks.push(currentChunk.trim());\n        currentChunk = word;\n      } else {\n        // Single word is longer than byteLength, split it\n        const wordBytes = encoder.encode(word);\n        for (let i = 0; i < wordBytes.length; i += byteLength) {\n          const slice = wordBytes.slice(i, i + byteLength);\n          chunks.push(new TextDecoder().decode(slice));\n        }\n        currentChunk = \"\";\n      }\n    }\n  }\n\n  if (currentChunk.trim()) {\n    chunks.push(currentChunk.trim());\n  }\n\n  return chunks;\n}\n\n/**\n * Calculates the maximum message size based on configuration.\n */\nexport function calcMaxMesgSize(voiceConfig: TTSConfig): number {\n  // Use a fixed maximum size as configured in recent commits\n  return 4096;\n}\n\n/**\n * Creates SSML headers plus data for WebSocket communication.\n */\nexport function ssmlHeadersPlusData(requestId: string, timestamp: string, ssml: string): string {\n  return `X-RequestId:${requestId}\\r\\nContent-Type:application/ssml+xml\\r\\nX-Timestamp:${timestamp}Z\\r\\nPath:ssml\\r\\n\\r\\n${ssml}`;\n}","import { TRUSTED_CLIENT_TOKEN } from './constants';\nimport { SkewAdjustmentError } from \"./exceptions\";\n\nconst WIN_EPOCH = 11644473600;\nconst S_TO_NS = 1e9;\n\n/**\n * Isomorphic DRM class that works in both Node.js and browsers.\n * Uses appropriate crypto APIs based on the environment.\n */\nexport class IsomorphicDRM {\n  private static clockSkewSeconds = 0.0;\n\n  static adjClockSkewSeconds(skewSeconds: number) {\n    IsomorphicDRM.clockSkewSeconds += skewSeconds;\n  }\n\n  static getUnixTimestamp(): number {\n    return Date.now() / 1000 + IsomorphicDRM.clockSkewSeconds;\n  }\n\n  static parseRfc2616Date(date: string): number | null {\n    try {\n      return new Date(date).getTime() / 1000;\n    } catch (e) {\n      return null;\n    }\n  }\n\n  static handleClientResponseError(response: { status: number; headers: any }) {\n    let serverDate: string | null = null;\n\n    if ('headers' in response && typeof response.headers === 'object') {\n      if ('get' in response.headers && typeof response.headers.get === 'function') {\n        // Fetch Response object\n        serverDate = response.headers.get(\"date\");\n      } else {\n        // Plain object with headers\n        const headers = response.headers as Record<string, string>;\n        serverDate = headers[\"date\"] || headers[\"Date\"];\n      }\n    }\n\n    if (!serverDate) {\n      throw new SkewAdjustmentError(\"No server date in headers.\");\n    }\n    const serverDateParsed = IsomorphicDRM.parseRfc2616Date(serverDate);\n    if (serverDateParsed === null) {\n      throw new SkewAdjustmentError(`Failed to parse server date: ${serverDate}`);\n    }\n    const clientDate = IsomorphicDRM.getUnixTimestamp();\n    IsomorphicDRM.adjClockSkewSeconds(serverDateParsed - clientDate);\n  }\n\n  static async generateSecMsGec(): Promise<string> {\n    let ticks = IsomorphicDRM.getUnixTimestamp();\n    ticks += WIN_EPOCH;\n    ticks -= ticks % 300;\n    ticks *= S_TO_NS / 100;\n\n    const strToHash = `${ticks.toFixed(0)}${TRUSTED_CLIENT_TOKEN}`;\n\n    // Use Web Crypto API directly - available in both Node.js 16+ and browsers\n    if (!globalThis.crypto || !globalThis.crypto.subtle) {\n      throw new Error('Web Crypto API not available');\n    }\n\n    const encoder = new TextEncoder();\n    const data = encoder.encode(strToHash);\n    const hashBuffer = await globalThis.crypto.subtle.digest('SHA-256', data);\n    const hashArray = Array.from(new Uint8Array(hashBuffer));\n    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('').toUpperCase();\n  }\n} ","import {\n  connectId,\n  dateToString,\n  escape,\n  mkssml,\n  removeIncompatibleCharacters,\n  splitTextByByteLength,\n  ssmlHeadersPlusData,\n  unescape\n} from './isomorphic-utils';\nimport {\n  NoAudioReceived,\n  UnexpectedResponse,\n  UnknownResponse,\n  WebSocketError\n} from \"./exceptions\";\nimport { TTSConfig } from './tts_config';\nimport { DEFAULT_VOICE, WSS_URL, SEC_MS_GEC_VERSION, WSS_HEADERS } from './constants';\nimport { IsomorphicDRM } from './isomorphic-drm';\n\n// Isomorphic buffer handling - works in both Node.js and browsers\nconst IsomorphicBuffer = {\n  from: (input: string | ArrayBuffer | Uint8Array, encoding?: string): Uint8Array => {\n    if (typeof input === 'string') {\n      return new TextEncoder().encode(input);\n    } else if (input instanceof ArrayBuffer) {\n      return new Uint8Array(input);\n    } else if (input instanceof Uint8Array) {\n      return input;\n    }\n    throw new Error('Unsupported input type for IsomorphicBuffer.from');\n  },\n\n  concat: (arrays: Uint8Array[]): Uint8Array => {\n    const totalLength = arrays.reduce((sum, arr) => sum + arr.length, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const arr of arrays) {\n      result.set(arr, offset);\n      offset += arr.length;\n    }\n    return result;\n  },\n\n  isBuffer: (obj: any): obj is Uint8Array => {\n    return obj instanceof Uint8Array;\n  },\n\n  toString: (buffer: Uint8Array, encoding?: string): string => {\n    return new TextDecoder(encoding || 'utf-8').decode(buffer);\n  }\n};\n\n// Isomorphic versions of utility functions that handle both Buffer and Uint8Array\nfunction isomorphicGetHeadersAndDataFromText(message: Uint8Array): [{ [key: string]: string }, Uint8Array] {\n  const messageString = IsomorphicBuffer.toString(message);\n  const headerEndIndex = messageString.indexOf('\\r\\n\\r\\n');\n\n  const headers: { [key: string]: string } = {};\n  if (headerEndIndex !== -1) {\n    const headerString = messageString.substring(0, headerEndIndex);\n    const headerLines = headerString.split('\\r\\n');\n    for (const line of headerLines) {\n      const [key, value] = line.split(':', 2);\n      if (key && value) {\n        headers[key] = value.trim();\n      }\n    }\n  }\n\n  const headerByteLength = new TextEncoder().encode(messageString.substring(0, headerEndIndex + 4)).length;\n  return [headers, message.slice(headerByteLength)];\n}\n\nfunction isomorphicGetHeadersAndDataFromBinary(message: Uint8Array): [{ [key: string]: string }, Uint8Array] {\n  if (message.length < 2) {\n    throw new Error('Message too short to contain header length');\n  }\n\n  const headerLength = (message[0] << 8) | message[1]; // Read big-endian uint16\n  const headers: { [key: string]: string } = {};\n\n  if (headerLength > 0 && headerLength + 2 <= message.length) {\n    const headerBytes = message.slice(2, headerLength + 2);\n    const headerString = IsomorphicBuffer.toString(headerBytes);\n    const headerLines = headerString.split('\\r\\n');\n    for (const line of headerLines) {\n      const [key, value] = line.split(':', 2);\n      if (key && value) {\n        headers[key] = value.trim();\n      }\n    }\n  }\n\n  return [headers, message.slice(headerLength + 2)];\n}\n\n// Isomorphic state interface using Uint8Array\ninterface IsomorphicCommunicateState {\n  partialText: Uint8Array;\n  offsetCompensation: number;\n  lastDurationOffset: number;\n  streamWasCalled: boolean;\n}\n\n// Isomorphic TTSChunk type using Uint8Array\ninterface IsomorphicTTSChunk {\n  type: \"audio\" | \"WordBoundary\";\n  data?: Uint8Array;\n  duration?: number;\n  offset?: number;\n  text?: string;\n}\n\n/**\n * Configuration options for the isomorphic Communicate class.\n */\nexport interface IsomorphicCommunicateOptions {\n  /** Voice to use for synthesis (e.g., \"en-US-EmmaMultilingualNeural\") */\n  voice?: string;\n  /** Speech rate adjustment (e.g., \"+20%\", \"-10%\") */\n  rate?: string;\n  /** Volume level adjustment (e.g., \"+50%\", \"-25%\") */\n  volume?: string;\n  /** Pitch adjustment in Hz (e.g., \"+5Hz\", \"-10Hz\") */\n  pitch?: string;\n  /** Proxy URL for requests (Node.js only) */\n  proxy?: string;\n  /** WebSocket connection timeout in milliseconds */\n  connectionTimeout?: number;\n}\n\n/**\n * Isomorphic Communicate class that works in both Node.js and browsers.\n * Uses isomorphic packages to provide consistent functionality across environments.\n * \n * @example\n * ```typescript\n * // Works in both Node.js and browsers (with CORS considerations)\n * const communicate = new IsomorphicCommunicate('Hello, world!', {\n *   voice: 'en-US-EmmaMultilingualNeural',\n * });\n * \n * for await (const chunk of communicate.stream()) {\n *   if (chunk.type === 'audio' && chunk.data) {\n *     // Handle audio data\n *   }\n * }\n * ```\n */\nexport class IsomorphicCommunicate {\n  private readonly ttsConfig: TTSConfig;\n  private readonly texts: Generator<Uint8Array>;\n  // Universal build - proxy and environment detection removed for compatibility\n\n  private state: IsomorphicCommunicateState = {\n    partialText: IsomorphicBuffer.from(''),\n    offsetCompensation: 0,\n    lastDurationOffset: 0,\n    streamWasCalled: false,\n  };\n\n  /**\n   * Creates a new isomorphic Communicate instance for text-to-speech synthesis.\n   * \n   * @param text - The text to synthesize\n   * @param options - Configuration options for synthesis\n   */\n  constructor(text: string, options: IsomorphicCommunicateOptions = {}) {\n    this.ttsConfig = new TTSConfig({\n      voice: options.voice || DEFAULT_VOICE,\n      rate: options.rate,\n      volume: options.volume,\n      pitch: options.pitch,\n    });\n\n    if (typeof text !== 'string') {\n      throw new TypeError('text must be a string');\n    }\n\n    // Create a generator that yields Uint8Array chunks instead of Buffer chunks\n    const processedText = escape(removeIncompatibleCharacters(text));\n    // const maxSize = calcMaxMesgSize(this.ttsConfig);\n    const maxSize = 4096;\n\n    this.texts = (function* () {\n      for (const chunk of splitTextByByteLength(processedText, maxSize)) {\n        // splitTextByByteLength returns strings, convert to Uint8Array\n        yield new TextEncoder().encode(chunk);\n      }\n    })();\n\n    // Note: proxy and connectionTimeout are not supported in universal builds\n    // for maximum compatibility across environments\n  }\n\n  private parseMetadata(data: Uint8Array): IsomorphicTTSChunk {\n    const metadata = JSON.parse(IsomorphicBuffer.toString(data));\n    for (const metaObj of metadata['Metadata']) {\n      const metaType = metaObj['Type'];\n      if (metaType === 'WordBoundary') {\n        const currentOffset = metaObj['Data']['Offset'] + this.state.offsetCompensation;\n        const currentDuration = metaObj['Data']['Duration'];\n        return {\n          type: metaType,\n          offset: currentOffset,\n          duration: currentDuration,\n          text: unescape(metaObj['Data']['text']['Text']),\n        };\n      }\n      if (metaType === 'SessionEnd') {\n        continue;\n      }\n      throw new UnknownResponse(`Unknown metadata type: ${metaType}`);\n    }\n    throw new UnexpectedResponse('No WordBoundary metadata found');\n  }\n\n  private async createWebSocket(url: string): Promise<WebSocket> {\n    // Handle WebSocket creation across different environments\n    const isNode = typeof globalThis !== 'undefined'\n      ? globalThis.process?.versions?.node !== undefined\n      : typeof process !== 'undefined' && process.versions?.node !== undefined;\n\n    if (isNode) {\n      // Node.js: Try to dynamically import ws library for better compatibility\n      try {\n        const { default: WS } = await import('ws');\n        return new WS(url, {\n          headers: WSS_HEADERS,\n        }) as any;\n      } catch (error) {\n        // Fall back to native Node.js WebSocket if ws not available\n        console.warn('ws library not available, using native WebSocket without headers');\n        return new WebSocket(url);\n      }\n    } else {\n      // Browser/Deno: Use native WebSocket\n      // Browsers automatically set appropriate headers like Origin\n      return new WebSocket(url);\n    }\n  }\n\n  private async * _stream(): AsyncGenerator<IsomorphicTTSChunk, void, unknown> {\n    const url = `${WSS_URL}&Sec-MS-GEC=${await IsomorphicDRM.generateSecMsGec()}&Sec-MS-GEC-Version=${SEC_MS_GEC_VERSION}&ConnectionId=${connectId()}`;\n\n    const websocket = await this.createWebSocket(url);\n    const messageQueue: (IsomorphicTTSChunk | Error | 'close')[] = [];\n    let resolveMessage: (() => void) | null = null;\n\n    // Handle different message event APIs\n    const handleMessage = (message: any, isBinary?: boolean) => {\n      // In browsers, message.data contains the data\n      const data = message.data || message;\n      const binary = isBinary ?? (data instanceof ArrayBuffer || data instanceof Uint8Array);\n\n      if (!binary && typeof data === 'string') {\n        // Text message\n        const [headers, parsedData] = isomorphicGetHeadersAndDataFromText(IsomorphicBuffer.from(data));\n\n        const path = headers['Path'];\n        if (path === 'audio.metadata') {\n          try {\n            const parsedMetadata = this.parseMetadata(parsedData);\n            this.state.lastDurationOffset = parsedMetadata.offset! + parsedMetadata.duration!;\n            messageQueue.push(parsedMetadata);\n          } catch (e) {\n            messageQueue.push(e as Error);\n          }\n        } else if (path === 'turn.end') {\n          this.state.offsetCompensation = this.state.lastDurationOffset;\n          websocket.close();\n        } else if (path !== 'response' && path !== 'turn.start') {\n          messageQueue.push(new UnknownResponse(`Unknown path received: ${path}`));\n        }\n      } else {\n        // Binary message - handle various binary data types across platforms\n        let bufferData: Uint8Array;\n\n        if (data instanceof ArrayBuffer) {\n          bufferData = IsomorphicBuffer.from(data);\n        } else if (data instanceof Uint8Array) {\n          bufferData = data;\n        } else if (typeof Buffer !== 'undefined' && data instanceof Buffer) {\n          // Node.js Buffer support\n          bufferData = new Uint8Array(data);\n        } else if (typeof Blob !== 'undefined' && data instanceof Blob) {\n          // Handle Blob from native Node.js WebSocket - process async\n          data.arrayBuffer().then(arrayBuffer => {\n            const blobBufferData = new Uint8Array(arrayBuffer);\n            processBinaryData(blobBufferData);\n          }).catch(error => {\n            messageQueue.push(new UnexpectedResponse(`Failed to process Blob data: ${error.message}`));\n            if (resolveMessage) resolveMessage();\n          });\n          return;\n        } else {\n          messageQueue.push(new UnexpectedResponse(`Unknown binary data type: ${typeof data} ${data.constructor?.name}`));\n          return;\n        }\n\n        processBinaryData(bufferData);\n      }\n\n      if (resolveMessage) resolveMessage();\n    };\n\n    const processBinaryData = (bufferData: Uint8Array) => {\n      if (bufferData.length < 2) {\n        messageQueue.push(new UnexpectedResponse('We received a binary message, but it is missing the header length.'));\n      } else {\n        const [headers, audioData] = isomorphicGetHeadersAndDataFromBinary(bufferData);\n\n        if (headers['Path'] !== 'audio') {\n          messageQueue.push(new UnexpectedResponse('Received binary message, but the path is not audio.'));\n        } else {\n          const contentType = headers['Content-Type'];\n          if (contentType !== 'audio/mpeg') {\n            if (audioData.length > 0) {\n              messageQueue.push(new UnexpectedResponse('Received binary message, but with an unexpected Content-Type.'));\n            }\n          } else if (audioData.length === 0) {\n            messageQueue.push(new UnexpectedResponse('Received binary message, but it is missing the audio data.'));\n          } else {\n            messageQueue.push({ type: 'audio', data: audioData });\n          }\n        }\n      }\n    };\n\n    // Use standard WebSocket event handlers that work universally\n    websocket.onmessage = handleMessage;\n    websocket.onerror = (error: any) => {\n      messageQueue.push(new WebSocketError(error.message || 'WebSocket error'));\n      if (resolveMessage) resolveMessage();\n    };\n    websocket.onclose = () => {\n      messageQueue.push('close');\n      if (resolveMessage) resolveMessage();\n    };\n\n    // Wait for connection\n    await new Promise<void>((resolve, reject) => {\n      const onOpen = () => resolve();\n      const onError = (error: any) => reject(error);\n\n      websocket.onopen = onOpen;\n      websocket.onerror = onError;\n    });\n\n    // Send configuration\n    websocket.send(\n      `X-Timestamp:${dateToString()}\\r\\n`\n      + 'Content-Type:application/json; charset=utf-8\\r\\n'\n      + 'Path:speech.config\\r\\n\\r\\n'\n      + '{\"context\":{\"synthesis\":{\"audio\":{\"metadataoptions\":{'\n      + '\"sentenceBoundaryEnabled\":\"false\",\"wordBoundaryEnabled\":\"true\"},'\n      + '\"outputFormat\":\"audio-24khz-48kbitrate-mono-mp3\"'\n      + '}}}}\\r\\n'\n    );\n\n    // Send SSML\n    websocket.send(\n      ssmlHeadersPlusData(\n        connectId(),\n        dateToString(),\n        mkssml(this.ttsConfig, IsomorphicBuffer.toString(this.state.partialText)),\n      )\n    );\n\n    // Process messages\n    let audioWasReceived = false;\n    while (true) {\n      if (messageQueue.length > 0) {\n        const message = messageQueue.shift()!;\n        if (message === 'close') {\n          if (!audioWasReceived) {\n            throw new NoAudioReceived('No audio was received.');\n          }\n          break;\n        } else if (message instanceof Error) {\n          throw message;\n        } else {\n          if (message.type === 'audio') audioWasReceived = true;\n          yield message;\n        }\n      } else {\n        // Use a more responsive wait mechanism\n        await new Promise<void>(resolve => {\n          resolveMessage = resolve;\n          // Add a small timeout to prevent indefinite waiting\n          setTimeout(resolve, 50);\n        });\n      }\n    }\n  }\n\n  /**\n   * Streams text-to-speech synthesis results using isomorphic WebSocket.\n   * Works in both Node.js and browsers (subject to CORS policy).\n   * \n   * @yields TTSChunk - Audio data or word boundary information\n   * @throws {Error} If called more than once\n   * @throws {NoAudioReceived} If no audio data is received\n   * @throws {WebSocketError} If WebSocket connection fails\n   */\n  async * stream(): AsyncGenerator<IsomorphicTTSChunk, void, unknown> {\n    if (this.state.streamWasCalled) {\n      throw new Error('stream can only be called once.');\n    }\n    this.state.streamWasCalled = true;\n\n    for (const partialText of this.texts) {\n      this.state.partialText = partialText;\n      for await (const message of this._stream()) {\n        yield message;\n      }\n    }\n  }\n} ","// Use native fetch API available in both Node.js 18+ and browsers\nimport { SEC_MS_GEC_VERSION, VOICE_HEADERS, VOICE_LIST_URL } from './constants';\nimport { IsomorphicDRM } from './isomorphic-drm';\nimport { Voice, VoicesManagerFind, VoicesManagerVoice } from './types';\n\n/**\n * Error class for fetch-related errors (isomorphic equivalent of AxiosError)\n */\nexport class FetchError extends Error {\n  response?: {\n    status: number;\n    headers: Record<string, string>;\n  };\n\n  constructor(message: string, response?: { status: number; headers: Record<string, string> }) {\n    super(message);\n    this.name = 'FetchError';\n    this.response = response;\n  }\n}\n\nasync function _listVoices(proxy?: string): Promise<Voice[]> {\n  const url = `${VOICE_LIST_URL}&Sec-MS-GEC=${await IsomorphicDRM.generateSecMsGec()}&Sec-MS-GEC-Version=${SEC_MS_GEC_VERSION}`;\n\n  const fetchOptions: RequestInit = {\n    headers: VOICE_HEADERS,\n  };\n\n  // Note: Proxy support in browsers is limited and handled differently\n  // In Node.js, we could potentially use a proxy agent with fetch\n  if (proxy) {\n    console.warn('Proxy support in isomorphic environment is limited. Consider using a backend proxy.');\n  }\n\n  try {\n    const response = await fetch(url, fetchOptions);\n\n    if (!response.ok) {\n      const headers: Record<string, string> = {};\n      response.headers.forEach((value, key) => {\n        headers[key] = value;\n      });\n\n      throw new FetchError(`HTTP ${response.status}`, {\n        status: response.status,\n        headers\n      });\n    }\n\n    const data: Voice[] = await response.json();\n\n    for (const voice of data) {\n      voice.VoiceTag.ContentCategories = voice.VoiceTag.ContentCategories.map(c => c.trim() as any);\n      voice.VoiceTag.VoicePersonalities = voice.VoiceTag.VoicePersonalities.map(p => p.trim() as any);\n    }\n\n    return data;\n  } catch (error) {\n    if (error instanceof FetchError) {\n      throw error;\n    }\n    // Convert other fetch errors to our FetchError format\n    throw new FetchError(error instanceof Error ? error.message : 'Unknown fetch error');\n  }\n}\n\n/**\n * Fetches all available voices from the Microsoft Edge TTS service (isomorphic version).\n * Works in both Node.js and browsers (subject to CORS policy).\n * \n * @param proxy - Optional proxy URL for the request (limited browser support)\n * @returns Promise resolving to array of available voices\n */\nexport async function listVoices(proxy?: string): Promise<Voice[]> {\n  try {\n    return await _listVoices(proxy);\n  } catch (e) {\n    if (e instanceof FetchError && e.response?.status === 403) {\n      IsomorphicDRM.handleClientResponseError(e.response);\n      return await _listVoices(proxy);\n    }\n    throw e;\n  }\n}\n\n/**\n * Isomorphic utility class for finding and filtering available voices.\n * Works in both Node.js and browsers (subject to CORS policy).\n * \n * @example\n * ```typescript\n * const voicesManager = await IsomorphicVoicesManager.create();\n * const englishVoices = voicesManager.find({ Language: 'en' });\n * ```\n */\nexport class IsomorphicVoicesManager {\n  private voices: VoicesManagerVoice[] = [];\n  private calledCreate = false;\n\n  /**\n   * Creates a new IsomorphicVoicesManager instance.\n   * \n   * @param customVoices - Optional custom voice list instead of fetching from API\n   * @param proxy - Optional proxy URL for API requests (limited browser support)\n   * @returns Promise resolving to IsomorphicVoicesManager instance\n   */\n  public static async create(customVoices?: Voice[], proxy?: string): Promise<IsomorphicVoicesManager> {\n    const manager = new IsomorphicVoicesManager();\n    const voices = customVoices ?? await listVoices(proxy);\n    manager.voices = voices.map(voice => ({\n      ...voice,\n      Language: voice.Locale.split('-')[0],\n    }));\n    manager.calledCreate = true;\n    return manager;\n  }\n\n  /**\n   * Finds voices matching the specified criteria.\n   * \n   * @param filter - Filter criteria for voice selection\n   * @returns Array of voices matching the filter\n   * @throws {Error} If called before create()\n   */\n  public find(filter: VoicesManagerFind): VoicesManagerVoice[] {\n    if (!this.calledCreate) {\n      throw new Error('IsomorphicVoicesManager.find() called before IsomorphicVoicesManager.create()');\n    }\n\n    return this.voices.filter(voice => {\n      return Object.entries(filter).every(([key, value]) => {\n        return voice[key as keyof VoicesManagerFind] === value;\n      });\n    });\n  }\n} ","import { IsomorphicCommunicate } from './isomorphic-communicate';\n\n/**\n * Options for controlling the voice prosody (rate, pitch, volume).\n */\nexport interface ProsodyOptions {\n  /**\n   * The speaking rate of the voice.\n   * Examples: \"+10.00%\", \"-20.00%\"\n   */\n  rate?: string;\n  /**\n   * The speaking volume of the voice.\n   * Examples: \"+15.00%\", \"-10.00%\"\n   */\n  volume?: string;\n  /**\n   * The speaking pitch of the voice.\n   * Examples: \"+20Hz\", \"-10Hz\"\n   */\n  pitch?: string;\n}\n\n/**\n * Represents a single word boundary with its timing and text.\n * The API provides timing in 100-nanosecond units.\n */\nexport interface WordBoundary {\n  /**\n   * The offset from the beginning of the audio stream in 100-nanosecond units.\n   */\n  offset: number;\n  /**\n   * The duration of the word in 100-nanosecond units.\n   */\n  duration: number;\n  /**\n   * The text of the spoken word.\n   */\n  text: string;\n}\n\n/**\n * The final result of the synthesis process.\n */\nexport interface SynthesisResult {\n  /**\n   * The generated audio as a Blob, which can be used in an <audio> element.\n   */\n  audio: Blob;\n  /**\n   * An array of word boundaries containing timing and text for creating subtitles.\n   */\n  subtitle: WordBoundary[];\n}\n\n// Browser-compatible buffer concatenation utility with improved audio handling\nfunction concatUint8Arrays(arrays: Uint8Array[]): Uint8Array {\n  if (arrays.length === 0) return new Uint8Array(0);\n  if (arrays.length === 1) return arrays[0];\n\n  // For audio data, we want to ensure smooth concatenation\n  const totalLength = arrays.reduce((sum, arr) => sum + arr.length, 0);\n  const result = new Uint8Array(totalLength);\n  let offset = 0;\n\n  for (const arr of arrays) {\n    if (arr.length > 0) {\n      result.set(arr, offset);\n      offset += arr.length;\n    }\n  }\n\n  return result;\n}\n\n/**\n * Isomorphic Edge TTS class that works in both Node.js and browser environments.\n * Uses isomorphic implementations to avoid platform-specific dependencies.\n */\nexport class IsomorphicEdgeTTS {\n  public text: string;\n  public voice: string;\n  public rate: string;\n  public volume: string;\n  public pitch: string;\n\n  /**\n   * @param text The text to be synthesized.\n   * @param voice The voice to use for synthesis.\n   * @param options Prosody options (rate, volume, pitch).\n   */\n  constructor(\n    text: string,\n    voice = \"Microsoft Server Speech Text to Speech Voice (en-US, EmmaMultilingualNeural)\",\n    options: ProsodyOptions = {}\n  ) {\n    this.text = text;\n    this.voice = voice;\n    this.rate = options.rate || \"+0%\";\n    this.volume = options.volume || \"+0%\";\n    this.pitch = options.pitch || \"+0Hz\";\n  }\n\n  /**\n   * Initiates the synthesis process using isomorphic implementations.\n   * @returns A promise that resolves with the synthesized audio and subtitle data.\n   */\n  public async synthesize(): Promise<SynthesisResult> {\n    const communicate = new IsomorphicCommunicate(this.text, {\n      voice: this.voice,\n      rate: this.rate,\n      volume: this.volume,\n      pitch: this.pitch,\n    });\n\n    const audioChunks: Uint8Array[] = [];\n    const wordBoundaries: WordBoundary[] = [];\n\n    for await (const chunk of communicate.stream()) {\n      if (chunk.type === 'audio' && chunk.data) {\n        audioChunks.push(chunk.data);\n      } else if (chunk.type === 'WordBoundary' && chunk.offset !== undefined && chunk.duration !== undefined && chunk.text !== undefined) {\n        wordBoundaries.push({\n          offset: chunk.offset,\n          duration: chunk.duration,\n          text: chunk.text,\n        });\n      }\n    }\n\n    // Convert Uint8Array chunks to Blob (works in both Node.js and browsers)\n    const audioBuffer = concatUint8Arrays(audioChunks);\n    // TS 5.5+ tightens BlobPart types to require ArrayBuffer-backed views.\n    // Our Uint8Array is ArrayBuffer-backed, so cast for type compatibility.\n    const audioBlob = new Blob([\n      audioBuffer as unknown as ArrayBufferView<ArrayBuffer>\n    ], { type: \"audio/mpeg\" });\n\n    return {\n      audio: audioBlob,\n      subtitle: wordBoundaries,\n    };\n  }\n}\n\n// ==================================================================================\n// Subtitle Generation Utilities (Isomorphic - works everywhere)\n// ==================================================================================\n\n/**\n * Formats a time value from 100-nanosecond units into a VTT or SRT timestamp string.\n * @param timeIn100ns The time value in 100-nanosecond units.\n * @param format The subtitle format, which determines the decimal separator.\n * @returns A formatted timestamp string (e.g., \"00:01:23.456\").\n */\nfunction formatTimestamp(timeIn100ns: number, format: 'vtt' | 'srt'): string {\n  const totalSeconds = Math.floor(timeIn100ns / 10000000);\n  const hours = Math.floor(totalSeconds / 3600);\n  const minutes = Math.floor((totalSeconds % 3600) / 60);\n  const seconds = totalSeconds % 60;\n  const milliseconds = Math.floor((timeIn100ns % 10000000) / 10000);\n  const separator = format === 'vtt' ? '.' : ',';\n  return `${padNumber(hours)}:${padNumber(minutes)}:${padNumber(seconds)}${separator}${padNumber(milliseconds, 3)}`;\n}\n\n/**\n * Pads a number with leading zeros to a specified length.\n * @param num The number to pad.\n * @param length The desired length of the string.\n * @returns The padded number as a string.\n */\nfunction padNumber(num: number, length = 2): string {\n  return num.toString().padStart(length, '0');\n}\n\n/**\n * Creates a subtitle file content in VTT (WebVTT) format.\n * @param wordBoundaries The array of word boundary data.\n * @returns A string containing the VTT formatted subtitles.\n */\nexport function createVTT(wordBoundaries: WordBoundary[]): string {\n  let vttContent = \"WEBVTT\\n\\n\";\n  wordBoundaries.forEach((word, index) => {\n    const startTime = formatTimestamp(word.offset, 'vtt');\n    const endTime = formatTimestamp(word.offset + word.duration, 'vtt');\n    vttContent += `${index + 1}\\n`;\n    vttContent += `${startTime} --> ${endTime}\\n`;\n    vttContent += `${word.text}\\n\\n`;\n  });\n  return vttContent;\n}\n\n/**\n * Creates a subtitle file content in SRT (SubRip) format.\n * @param wordBoundaries The array of word boundary data.\n * @returns A string containing the SRT formatted subtitles.\n */\nexport function createSRT(wordBoundaries: WordBoundary[]): string {\n  let srtContent = \"\";\n  wordBoundaries.forEach((word, index) => {\n    const startTime = formatTimestamp(word.offset, 'srt');\n    const endTime = formatTimestamp(word.offset + word.duration, 'srt');\n    srtContent += `${index + 1}\\n`;\n    srtContent += `${startTime} --> ${endTime}\\n`;\n    srtContent += `${word.text}\\n\\n`;\n  });\n  return srtContent;\n} \n","/**\n * Browser-compatible version of edge-tts Simple API\n * Uses native browser APIs instead of Node.js dependencies\n */\n\n/**\n * Options for controlling the voice prosody (rate, pitch, volume).\n */\nexport interface ProsodyOptions {\n  /**\n   * The speaking rate of the voice.\n   * Examples: \"+10.00%\", \"-20.00%\"\n   */\n  rate?: string;\n  /**\n   * The speaking volume of the voice.\n   * Examples: \"+15.00%\", \"-10.00%\"\n   */\n  volume?: string;\n  /**\n   * The speaking pitch of the voice.\n   * Examples: \"+20Hz\", \"-10Hz\"\n   */\n  pitch?: string;\n}\n\n/**\n * Represents a single word boundary with its timing and text.\n * The API provides timing in 100-nanosecond units.\n */\nexport interface WordBoundary {\n  /**\n   * The offset from the beginning of the audio stream in 100-nanosecond units.\n   */\n  offset: number;\n  /**\n   * The duration of the word in 100-nanosecond units.\n   */\n  duration: number;\n  /**\n   * The text of the spoken word.\n   */\n  text: string;\n}\n\n/**\n * The final result of the synthesis process.\n */\nexport interface SynthesisResult {\n  /**\n   * The generated audio as a Blob, which can be used in an <audio> element.\n   */\n  audio: Blob;\n  /**\n   * An array of word boundaries containing timing and text for creating subtitles.\n   */\n  subtitle: WordBoundary[];\n}\n\n/**\n * Browser-compatible Edge TTS class that uses native browser APIs.\n * \n * @remarks This uses an undocumented Microsoft API. CORS policy may prevent\n * direct usage from web apps. Consider using a proxy server.\n */\nexport class EdgeTTSBrowser {\n  public text: string;\n  public voice: string;\n  public rate: string;\n  public volume: string;\n  public pitch: string;\n\n  private ws: WebSocket | null = null;\n  private readonly WSS_URL = \"wss://speech.platform.bing.com/consumer/speech/synthesize/readaloud/edge/v1\";\n  private readonly TRUSTED_CLIENT_TOKEN = \"6A5AA1D4EAFF4E9FB37E23D68491D6F4\";\n\n  /**\n   * @param text The text to be synthesized.\n   * @param voice The voice to use for synthesis.\n   * @param options Prosody options (rate, volume, pitch).\n   */\n  constructor(\n    text: string,\n    voice = \"Microsoft Server Speech Text to Speech Voice (en-US, EmmaMultilingualNeural)\",\n    options: ProsodyOptions = {}\n  ) {\n    this.text = text;\n    this.voice = voice;\n    this.rate = options.rate || \"+0%\";\n    this.volume = options.volume || \"+0%\";\n    this.pitch = options.pitch || \"+0Hz\";\n  }\n\n  /**\n   * Initiates the synthesis process.\n   * @returns A promise that resolves with the synthesized audio and subtitle data.\n   */\n  public async synthesize(): Promise<SynthesisResult> {\n    await this.connect();\n\n    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {\n      throw new Error(\"WebSocket is not connected.\");\n    }\n\n    this.ws.send(this.createSpeechConfig());\n    this.ws.send(this.createSSML());\n\n    return new Promise((resolve, reject) => {\n      const audioChunks: Uint8Array[] = [];\n      let wordBoundaries: WordBoundary[] = [];\n\n      if (this.ws) {\n        this.ws.onmessage = (event: MessageEvent) => {\n          if (typeof event.data === \"string\") {\n            // Text message\n            const { headers, body } = this.parseMessage(event.data);\n            if (headers.Path === \"audio.metadata\") {\n              try {\n                const metadata = JSON.parse(body);\n                if (metadata.Metadata && Array.isArray(metadata.Metadata)) {\n                  const boundaries = metadata.Metadata\n                    .filter((item: any) => item.Type === \"WordBoundary\" && item.Data)\n                    .map((item: any) => ({\n                      offset: item.Data.Offset,\n                      duration: item.Data.Duration,\n                      text: item.Data.text.Text,\n                    }));\n                  wordBoundaries = wordBoundaries.concat(boundaries);\n                }\n              } catch (e) {\n                // Ignore JSON parsing errors for metadata\n              }\n            } else if (headers.Path === \"turn.end\") {\n              if (this.ws) this.ws.close();\n            }\n          } else if (event.data instanceof Blob) {\n            // Binary audio message\n            event.data.arrayBuffer().then(arrayBuffer => {\n              const dataView = new DataView(arrayBuffer);\n              const headerLength = dataView.getUint16(0);\n\n              if (arrayBuffer.byteLength > headerLength + 2) {\n                const audioData = new Uint8Array(arrayBuffer, headerLength + 2);\n                audioChunks.push(audioData);\n              }\n            });\n          }\n        };\n\n        this.ws.onclose = () => {\n          // TS 5.5+ requires BlobPart views to be ArrayBuffer-backed.\n          // Our chunks are Uint8Array; cast them for type compatibility.\n          const audioBlob = new Blob(\n            audioChunks as unknown as ArrayBufferView<ArrayBuffer>[],\n            { type: \"audio/mpeg\" }\n          );\n          resolve({ audio: audioBlob, subtitle: wordBoundaries });\n        };\n\n        this.ws.onerror = (error) => {\n          reject(error);\n        };\n      }\n    });\n  }\n\n  /**\n   * Establishes a connection to the WebSocket server.\n   */\n  private connect(): Promise<void> {\n    const connectionId = this.generateConnectionId();\n    const secMsGec = this.generateSecMsGec();\n    const url = `${this.WSS_URL}?TrustedClientToken=${this.TRUSTED_CLIENT_TOKEN}&ConnectionId=${connectionId}&Sec-MS-GEC=${secMsGec}&Sec-MS-GEC-Version=1-130.0.2849.68`;\n\n    this.ws = new WebSocket(url);\n\n    return new Promise((resolve, reject) => {\n      if (!this.ws) {\n        return reject(new Error(\"WebSocket not initialized\"));\n      }\n      this.ws.onopen = () => {\n        resolve();\n      };\n      this.ws.onerror = (error) => {\n        reject(error);\n      };\n    });\n  }\n\n  /**\n   * Parses a string message from the WebSocket into headers and a body.\n   */\n  private parseMessage(message: string): { headers: Record<string, string>; body: string } {\n    const parts = message.split(\"\\r\\n\\r\\n\");\n    const headerLines = parts[0].split(\"\\r\\n\");\n    const headers: Record<string, string> = {};\n    headerLines.forEach(line => {\n      const [key, value] = line.split(\":\", 2);\n      if (key && value) {\n        headers[key.trim()] = value.trim();\n      }\n    });\n    return { headers, body: parts[1] || '' };\n  }\n\n  /**\n   * Creates the speech configuration message.\n   */\n  private createSpeechConfig(): string {\n    const config = {\n      context: {\n        synthesis: {\n          audio: {\n            metadataoptions: {\n              sentenceBoundaryEnabled: false,\n              wordBoundaryEnabled: true,\n            },\n            outputFormat: \"audio-24khz-48kbitrate-mono-mp3\",\n          },\n        },\n      },\n    };\n    return `X-Timestamp:${this.getTimestamp()}\\r\\nContent-Type:application/json; charset=utf-8\\r\\nPath:speech.config\\r\\n\\r\\n${JSON.stringify(config)}`;\n  }\n\n  /**\n   * Creates the SSML (Speech Synthesis Markup Language) message.\n   */\n  private createSSML(): string {\n    const ssml = `<speak version='1.0' xmlns='http://www.w3.org/2001/10/synthesis' xml:lang='en-US'>\n      <voice name='${this.voice}'>\n        <prosody pitch='${this.pitch}' rate='${this.rate}' volume='${this.volume}'>\n          ${this.escapeXml(this.text)}\n        </prosody>\n      </voice>\n    </speak>`;\n    return `X-RequestId:${this.generateConnectionId()}\\r\\nContent-Type:application/ssml+xml\\r\\nX-Timestamp:${this.getTimestamp()}Z\\r\\nPath:ssml\\r\\n\\r\\n${ssml}`;\n  }\n\n  private generateConnectionId(): string {\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c) => {\n      const r = (Math.random() * 16) | 0;\n      const v = c === \"x\" ? r : (r & 0x3) | 0x8;\n      return v.toString(16);\n    });\n  }\n\n  private getTimestamp(): string {\n    return new Date().toISOString().replace(/[:-]|\\.\\d{3}/g, \"\");\n  }\n\n  private escapeXml(text: string): string {\n    return text.replace(/[<>&'\"]/g, (char) => {\n      switch (char) {\n        case \"<\": return \"&lt;\";\n        case \">\": return \"&gt;\";\n        case \"&\": return \"&amp;\";\n        case \"'\": return \"&apos;\";\n        case '\"': return \"&quot;\";\n        default: return char;\n      }\n    });\n  }\n\n  /**\n   * Browser-compatible version of DRM security token generation\n   * Uses Web Crypto API instead of Node.js crypto\n   */\n  private async generateSecMsGec(): Promise<string> {\n    const WIN_EPOCH = 11644473600;\n    const S_TO_NS = 1e9;\n\n    let ticks = Date.now() / 1000;\n    ticks += WIN_EPOCH;\n    ticks -= ticks % 300;\n    ticks *= S_TO_NS / 100;\n\n    const strToHash = `${ticks.toFixed(0)}${this.TRUSTED_CLIENT_TOKEN}`;\n\n    // Use Web Crypto API for hashing\n    const encoder = new TextEncoder();\n    const data = encoder.encode(strToHash);\n    const hashBuffer = await crypto.subtle.digest('SHA-256', data);\n    const hashArray = Array.from(new Uint8Array(hashBuffer));\n    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('').toUpperCase();\n  }\n}\n\n// ==================================================================================\n// Subtitle Generation Utilities (Browser Compatible)\n// ==================================================================================\n\n/**\n * Formats a time value from 100-nanosecond units into a VTT or SRT timestamp string.\n */\nfunction formatTimestamp(timeIn100ns: number, format: 'vtt' | 'srt'): string {\n  const totalSeconds = Math.floor(timeIn100ns / 10000000);\n  const hours = Math.floor(totalSeconds / 3600);\n  const minutes = Math.floor((totalSeconds % 3600) / 60);\n  const seconds = totalSeconds % 60;\n  const milliseconds = Math.floor((timeIn100ns % 10000000) / 10000);\n  const separator = format === 'vtt' ? '.' : ',';\n  return `${padNumber(hours)}:${padNumber(minutes)}:${padNumber(seconds)}${separator}${padNumber(milliseconds, 3)}`;\n}\n\n/**\n * Pads a number with leading zeros to a specified length.\n */\nfunction padNumber(num: number, length = 2): string {\n  return num.toString().padStart(length, '0');\n}\n\n/**\n * Creates a subtitle file content in VTT (WebVTT) format.\n */\nexport function createVTT(wordBoundaries: WordBoundary[]): string {\n  let vttContent = \"WEBVTT\\n\\n\";\n  wordBoundaries.forEach((word, index) => {\n    const startTime = formatTimestamp(word.offset, 'vtt');\n    const endTime = formatTimestamp(word.offset + word.duration, 'vtt');\n    vttContent += `${index + 1}\\n`;\n    vttContent += `${startTime} --> ${endTime}\\n`;\n    vttContent += `${word.text}\\n\\n`;\n  });\n  return vttContent;\n}\n\n/**\n * Creates a subtitle file content in SRT (SubRip) format.\n */\nexport function createSRT(wordBoundaries: WordBoundary[]): string {\n  let srtContent = \"\";\n  wordBoundaries.forEach((word, index) => {\n    const startTime = formatTimestamp(word.offset, 'srt');\n    const endTime = formatTimestamp(word.offset + word.duration, 'srt');\n    srtContent += `${index + 1}\\n`;\n    srtContent += `${startTime} --> ${endTime}\\n`;\n    srtContent += `${word.text}\\n\\n`;\n  });\n  return srtContent;\n} \n"]}